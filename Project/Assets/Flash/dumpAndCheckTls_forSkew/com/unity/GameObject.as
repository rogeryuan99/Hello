package com.unity{	import flash.display.MovieClip;	import flash.events.TimerEvent;	import flash.geom.Point;	import flash.utils.Timer;	import flash.events.Event;	import flash.geom.Matrix;		public class GameObject extends MovieClip	{		private var _initXML:XML;		public var frameXML:XML;		private var t_mc:MovieClip;		private var isAlpha:Boolean;				public function GameObject()		{			super();			//return;			_initXML = <root/>;			frameXML = <act name="Move" totalFrame="17"/>;					}				public function startDump(targetMc:MovieClip, isAlpha:Boolean=false)		{			this.isAlpha = isAlpha;			t_mc = targetMc;			t_mc.gotoAndStop(1);			trace("==== action = "+t_mc.name);			frameXML = <act name={t_mc.name} totalFrame={t_mc.totalFrames}/>;			getInitPosData(targetMc);			startDumpFrameData();		}				public function getBone(mcArray:Array):XML		{			var finishedParts:Array = new Array();			var bone:XML = <root/>;			for(var n:int = 0;n<mcArray.length;n++){				t_mc = mcArray[n];				t_mc.gotoAndStop(1);				var amount:int = t_mc.numChildren;				for(var i:int=0; i<amount; i++)				{	//				trace(this.getChildAt(i).name);					var part:MovieClip = t_mc.getChildAt(i) as MovieClip;										if(finishedParts.indexOf(part.name)!= -1){						continue;					}else{						finishedParts.push(part.name);					}										var pt:Point = convertToUnityPt(part.x, part.y);					var pos:String = pt.x+"|"+pt.y;										var rt:Number = convertToUnityRt(part.rotation);										//bone.appendChild(<part name={part.name} pos={pos} roration={rt} epos={entityPos}/>);					bone.appendChild(<part name={part.name} />);				}			}			bone = sortXMLByAttribute( bone, "name");			return bone;		}				public function getInitPosData(targetMc:MovieClip):XML		{			_initXML = new XML();			t_mc = targetMc;			t_mc.gotoAndStop(1);			var amount:int = t_mc.numChildren;			for(var i:int=0; i<amount; i++)			{				trace(t_mc.getChildAt(i).name);				var part:MovieClip = t_mc.getChildAt(i) as MovieClip;				if(part == null){					var p = t_mc.getChildAt(i);					trace("xxxxx      at "+i+"  "+p.name+" is not a Movie Clip");					p.scaleX=20;					p.scaleY=20;				}								var pt:Point = convertToUnityPt(part.x, part.y);				var pos:String = pt.x+"|"+pt.y;								var rt:Number = convertToUnityRt(part.rotation);								//var ePt:Point = convertToUnityPt(part.entity.x, part.entity.y);				//var entityPos:String = ePt.x+"|"+ePt.y;				_initXML.appendChild(<part name={part.name}/>);				frameXML.appendChild(<{part.name}/>);							}			//trace(_initXML);			trace("=============");			//trace(frameXML);			return _initXML;			//trace(frameXML);		}		var timer:Timer;		public function startDumpFrameData()		{			timer = new Timer(100,t_mc.totalFrames);			timer.addEventListener(TimerEvent.TIMER, onTimer);			timer.addEventListener(TimerEvent.TIMER_COMPLETE, onTimerComplete);			timer.start();		}				private function onTimer(evt:TimerEvent):void{			trace(" ... 第["+t_mc.currentFrame+"]贞");								var amount:int = t_mc.numChildren;			for(var i:int=0; i<amount; i++)			{				//trace(t_mc.getChildAt(i).name);				var part:MovieClip = t_mc.getChildAt(i) as MovieClip;				if(part == null){					var p = t_mc.getChildAt(i);					trace("xxxxx      at "+i+"  "+p.name+" is not a Movie Clip");					p.scaleX=20;					p.scaleY=20;				}				var pt:Point = convertToUnityPt2(part.x, part.y);				var pos:String = pt.x+"|"+pt.y;								var rt:Number = convertToUnityRt(part.rotation);								//var ePt:Point = convertToUnityPt(part.entity.x, part.entity.y);				//var entityPos:String = ePt.x+"|"+ePt.y;								var scale:String = part.scaleX.toFixed(3)+"|"+part.scaleY.toFixed(3);				var matrix:Matrix = part.transform.matrix;				matrix.b = -matrix.b;				matrix.c = -matrix.c;				var matrixStr:String = matrix.a.toFixed(3)+"|"+matrix.b.toFixed(3)+"|"+matrix.c.toFixed(3)+"|"+matrix.d.toFixed(3);				var v:String = (part.alpha == 0)? "0":"";				var length2:int = frameXML[part.name]["data"].length();				if(length2 >0)				{					var xml_tt:XML = frameXML[part.name]["data"][length2-1];					if(xml_tt)					{						//trace(xml_tt.toXMLString());						if(xml_tt.@pos == pos && xml_tt.@m == matrixStr && xml_tt.@v == v)						{							continue;						}					}				}								try{								if(part.alpha == 0)				{					var prevXMLIndex:String = String(this.currentFrame-1);					var length:int = frameXML[part.name]["data"].length();					if(length >0)					{						var xml_t:XML = frameXML[part.name]["data"][length-1];						if(xml_t)						{							//trace(xml_t.toXMLString());							if(xml_t.@m == "0.001|0|0|0.001")							{								continue;							}						}					}					if(isAlpha)					{						frameXML[part.name].appendChild(<data pos={pos} frame={t_mc.currentFrame} m={"0.001|0|0|0.001"} a="0" v="0"/>);						//frameXML[part.name].appendChild(<data pos={pos} rotation={rt} scale={scale} frame={t_mc.currentFrame} a="0"/>);					}else{						frameXML[part.name].appendChild(<data pos={pos} frame={t_mc.currentFrame} m={"0.001|0|0|0.001"}  v="0"/>);						//frameXML[part.name].appendChild(<data pos={pos} rotation={rt} scale={scale} frame={t_mc.currentFrame} v="0"/>);					}				}else{					if(isAlpha)					{						frameXML[part.name].appendChild(<data pos={pos} frame={t_mc.currentFrame} m={matrixStr} a={part.alpha}/>);						//frameXML[part.name].appendChild(<data pos={pos} rotation={rt} scale={scale} frame={t_mc.currentFrame} m={matrixStr} a={part.alpha}/>);					}else{						frameXML[part.name].appendChild(<data pos={pos} frame={t_mc.currentFrame} m={matrixStr}/>);						//frameXML[part.name].appendChild(<data pos={pos} rotation={rt} scale={scale} frame={t_mc.currentFrame} m={matrixStr}/>);					}				}				}catch(e:*){					//matrix = part.transform.matrix;					//matrix.a *= 10;					//matrix.d *= 10;					//part.transform.matrix = matrix;					//trace(part.transform.matrix);					//part.scale*=10;					part.scaleX=11;					part.scaleY=11;					part.alpha = 100;					timer.removeEventListener(TimerEvent.TIMER, onTimer);					timer.removeEventListener(TimerEvent.TIMER_COMPLETE, onTimerComplete);					t_mc.stop();					if(frameXML[part.name] == null){						trace("Error: 第["+t_mc.currentFrame+"]贞有一个不应该存在的东西："+part.name  );											}else if(frameXML[part.name] is XMLList){						trace("Error: 第["+t_mc.currentFrame+"]贞有一个 重重重复复复 的东西："+part.name  );											}					trace("只有第一贞存在的东西合法，这个动作的第一贞包含："  );					trace(_initXML);									}											}			t_mc.gotoAndStop(t_mc.currentFrame+1);		}		private function onTimerComplete(evt:TimerEvent):void{			this.dispatchEvent(new Event(Event.COMPLETE));			//trace("action complete"+frameXML);		}				public static function convertToUnityPt(x:Number, y:Number):Point		{			return new Point(x, -y);		}		public static function convertToUnityPt2(x:Number, y:Number):Point		{			return new Point(x, -y);		}		public static function convertToUnityRt(rt:Number):Number		{			var tempRt:String = (-rt).toFixed(3);			return Number(tempRt);					}				public static function sortXMLByAttribute			(				$xml		:	XML,				$attribute	:	String,				$options	:	Object	=	null,				$copy		:	Boolean	=	false			)			:XML		 {			//store in array to sort on			var xmlArray:Array	= new Array();			var item:XML;			for each(item in $xml.children())			{				var object:Object = {					data	: item, 					order	: item.attribute($attribute)				};				xmlArray.push(object);			}					//sort using the power of Array.sortOn()			xmlArray.sortOn('order',$options);					//create a new XMLList with sorted XML			var sortedXmlList:XMLList = new XMLList();			var xmlObject:Object;			for each(xmlObject in xmlArray )			{				sortedXmlList += xmlObject.data;			}						if($copy)			{				//don't modify original				return	$xml.copy().setChildren(sortedXmlList);			}			else			{				//original modified				return $xml.setChildren(sortedXmlList);			}		 }			}}