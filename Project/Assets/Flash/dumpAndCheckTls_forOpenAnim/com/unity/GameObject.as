//last modified date  20121123//兔子动画需要的改动package com.unity{	import flash.display.MovieClip;	import flash.events.TimerEvent;	import flash.geom.Point;	import flash.utils.Timer;	import flash.events.Event;		public class GameObject extends MovieClip	{		private var _initXML:XML;		public var frameXML:XML;		private var t_mc:MovieClip;		private var isAlpha:Boolean;				public function GameObject()		{			super();			//return;			_initXML = <root/>;			frameXML = <act name="Move" totalFrame="17"/>;					}				public function startDump(targetMc:MovieClip, isAlpha:Boolean=false)		{			this.isAlpha = isAlpha;			t_mc = targetMc;			t_mc.gotoAndStop(1);			frameXML = <act name={t_mc.name} totalFrame={t_mc.totalFrames}/>;			getInitPosData(targetMc);			startDumpFrameData();		}				public function getInitPosData(targetMc:MovieClip):XML		{			t_mc = targetMc;			t_mc.gotoAndStop(1);			var amount:int = t_mc.numChildren;			for(var i:int=0; i<amount; i++)			{//				trace(this.getChildAt(i).name);				var part:MovieClip = t_mc.getChildAt(i) as MovieClip;				var pt:Point = convertToUnityPt(part.x, part.y);				var pos:String = pt.x+"|"+pt.y;								var rt:Number = convertToUnityRt(part.rotation);								var ePt:Point = convertToUnityPt(part.entity.x, part.entity.y);				var entityPos:String = ePt.x+"|"+ePt.y;								_initXML.appendChild(<part name={part.name} pos={pos} roration={rt==0?rt:rt.toFixed(3)} epos={entityPos}/>);				frameXML.appendChild(<{part.name}/>);			}			trace(_initXML);			return _initXML;			//trace(frameXML);		}				public function startDumpFrameData()		{			var timer:Timer = new Timer(100,t_mc.totalFrames);			timer.addEventListener(TimerEvent.TIMER, onTimer);			timer.addEventListener(TimerEvent.TIMER_COMPLETE, onTimerComplete);			timer.start();		}				private function onTimer(evt:TimerEvent):void{			var amount:int = t_mc.numChildren;			for(var i:int=0; i<amount; i++)			{				//				trace(this.getChildAt(i).name);				var part:MovieClip = t_mc.getChildAt(i) as MovieClip;				var pt:Point = convertToUnityPt2(part.x, part.y);				var pos:String = pt.x+"|"+pt.y;								var rt:Number = convertToUnityRt(part.rotation);				var rt_str:String = rt==0?rt.toString():rt.toFixed(3);								var ePt:Point = convertToUnityPt(part.entity.x, part.entity.y);				var entityPos:String = ePt.x+"|"+ePt.y;								var scale:String = part.scaleX.toFixed(3)+"|"+part.scaleY.toFixed(3);								var alpha_value:int = part.alpha;								var prevXMLIndex:String = String(this.currentFrame-1);				var length:int = frameXML[part.name]["data"].length();				if(length >0)				{					var xml_t:XML = frameXML[part.name]["data"][length-1];					if(xml_t)					{						//trace(xml_t.toXMLString());						//trace(xml_t.@epos +"  "+ entityPos);						//trace(xml_t.@v +"   "+ alpha_value);						if(xml_t.@pos == pos && xml_t.@rotation == rt_str && xml_t.@scale == scale)						{							//trace(xml_t.@v +"   "+ alpha_value);							if(xml_t.@a  ==  alpha_value)continue;							//continue;						}					}				}				if(part.alpha == 0)				{					if(isAlpha)					{						frameXML[part.name].appendChild(<data pos={pos} rotation={rt_str} scale={scale} frame={t_mc.currentFrame} a="0"/>);					}else{						var prevXMLIndex:String = String(this.currentFrame-1);						var length:int = frameXML[part.name]["data"].length();						if(length >0)						{							var xml_t:XML = frameXML[part.name]["data"][length-1];							if(xml_t)							{								//trace(xml_t.toXMLString());								if(xml_t.@v == "0")								{									continue;								}							}						}						frameXML[part.name].appendChild(<data pos={pos} rotation={rt_str} scale={scale} frame={t_mc.currentFrame} v="0"/>);					}				}else{					if(isAlpha)					{						frameXML[part.name].appendChild(<data pos={pos} rotation={rt_str} scale={scale} frame={t_mc.currentFrame} a={part.alpha}/>);					}else{						frameXML[part.name].appendChild(<data pos={pos} rotation={rt_str} scale={scale} frame={t_mc.currentFrame} />);					}				}			}			t_mc.gotoAndStop(t_mc.currentFrame+1);		}		private function onTimerComplete(evt:TimerEvent):void{			this.dispatchEvent(new Event(Event.COMPLETE));			trace(frameXML);		}				public static function convertToUnityPt(x:int, y:int):Point		{			return new Point(x, -y);		}		public static function convertToUnityPt2(x:Number, y:Number):Point		{			return new Point(x, -y);		}		public static function convertToUnityRt(rt:Number):Number		{			return -rt;		}	}}