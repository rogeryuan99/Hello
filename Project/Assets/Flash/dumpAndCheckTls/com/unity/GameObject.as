package com.unity{	import flash.display.MovieClip;	import flash.events.TimerEvent;	import flash.geom.Point;	import flash.utils.Timer;	import flash.events.Event;		public class GameObject extends MovieClip	{		private var _initXML:XML;		public var frameXML:XML;		private var t_mc:MovieClip;		private var isAlpha:Boolean;				public function GameObject()		{			super();			//return;			_initXML = <root/>;			frameXML = <act name="Move" totalFrame="17"/>;					}				public function startDump(targetMc:MovieClip, isAlpha:Boolean=false)		{			this.isAlpha = isAlpha;			t_mc = targetMc;			trace("startDump: gotoAndStop1.start");			t_mc.gotoAndStop(1);			trace("startDump: gotoAndStop1.end");			frameXML = <act name={t_mc.name} totalFrame={t_mc.totalFrames}/>;			getInitPosData(targetMc);			startDumpFrameData();		}				public function getBone(targetMc:MovieClip):XML		{			t_mc = targetMc;			t_mc.gotoAndStop(1);			var bone:XML = <root/>;			var amount:int = t_mc.numChildren;			for(var i:int=0; i<amount; i++)			{//				trace(this.getChildAt(i).name);				var part:MovieClip = t_mc.getChildAt(i) as MovieClip;				var pt:Point = convertToUnityPt(part.x, part.y);				var pos:String = pt.x+"|"+pt.y;								var rt:Number = convertToUnityRt(part.rotation);								var ePt:Point = convertToUnityPt(part.entity.x, part.entity.y);				var entityPos:String = ePt.x+"|"+ePt.y;								bone.appendChild(<part name={part.name} pos={pos} roration={rt} epos={entityPos}/>);			}			trace(bone);			return bone;		}				public function getInitPosData(targetMc:MovieClip):XML		{			t_mc = targetMc;			t_mc.gotoAndStop(1);			var amount:int = t_mc.numChildren;			for(var i:int=0; i<amount; i++)			{//				trace(this.getChildAt(i).name);				var part:MovieClip = t_mc.getChildAt(i) as MovieClip;				var pt:Point = convertToUnityPt(part.x, part.y);				var pos:String = pt.x+"|"+pt.y;								var rt:Number = convertToUnityRt(part.rotation);								var ePt:Point = convertToUnityPt(part.entity.x, part.entity.y);				var entityPos:String = ePt.x+"|"+ePt.y;								_initXML.appendChild(<part name={part.name} pos={pos} roration={rt} epos={entityPos}/>);				frameXML.appendChild(<{part.name}/>);			}			trace(_initXML);			return _initXML;			//trace(frameXML);		}				public function startDumpFrameData()		{			var timer:Timer = new Timer(100,t_mc.totalFrames);			timer.addEventListener(TimerEvent.TIMER, onTimer);			timer.addEventListener(TimerEvent.TIMER_COMPLETE, onTimerComplete);			timer.start();		}				private function onTimer(evt:TimerEvent):void{			var amount:int = t_mc.numChildren;			for(var i:int=0; i<amount; i++)			{				//				trace(this.getChildAt(i).name);				var part:MovieClip = t_mc.getChildAt(i) as MovieClip;				var pt:Point = convertToUnityPt2(part.x, part.y);				var pos:String = pt.x+"|"+pt.y;								var rt:Number = convertToUnityRt(part.rotation);								//var ePt:Point = convertToUnityPt(part.entity.x, part.entity.y);				//var entityPos:String = ePt.x+"|"+ePt.y;								var scale:String = part.scaleX.toFixed(3)+"|"+part.scaleY.toFixed(3);								/*var prevXMLIndex:String = String(this.currentFrame-1);				var length:int = frameXML[part.name]["data"].length();				if(length >0)				{					var xml_t:XML = frameXML[part.name]["data"][length-1];					if(xml_t)					{						//trace(xml_t.toXMLString());						if(xml_t.@pos == pos && xml_t.@rotation == rt && xml_t.@epos == entityPos && xml_t.@scale == scale)						{							continue;						}					}				}*/				if(part.alpha == 0)				{					if(isAlpha)					{						frameXML[part.name].appendChild(<data pos={pos} rotation={rt} scale={scale} frame={t_mc.currentFrame} a="0"/>);					}else{						var prevXMLIndex:String = String(this.currentFrame-1);						var length:int = frameXML[part.name]["data"].length();						if(length >0)						{							var xml_t:XML = frameXML[part.name]["data"][length-1];							if(xml_t)							{								//trace(xml_t.toXMLString());								if(xml_t.@v == "0")								{									continue;								}							}						}						frameXML[part.name].appendChild(<data pos={pos} rotation={rt} scale={scale} frame={t_mc.currentFrame} v="0"/>);					}				}else{					if(isAlpha)					{						frameXML[part.name].appendChild(<data pos={pos} rotation={rt} scale={scale} frame={t_mc.currentFrame} a={part.alpha}/>);					}else{						frameXML[part.name].appendChild(<data pos={pos} rotation={rt} scale={scale} frame={t_mc.currentFrame}/>);					}				}			}			t_mc.gotoAndStop(t_mc.currentFrame+1);		}		private function onTimerComplete(evt:TimerEvent):void{			this.dispatchEvent(new Event(Event.COMPLETE));			trace(frameXML);		}				public static function convertToUnityPt(x:Number, y:Number):Point		{			return new Point(x, -y);		}		public static function convertToUnityPt2(x:Number, y:Number):Point		{			return new Point(x, -y);		}		public static function convertToUnityRt(rt:Number):Number		{			var tempRt:String = (-rt).toFixed(3);			return Number(tempRt);					}	}}